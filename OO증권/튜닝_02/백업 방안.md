# OO증권 AGT_QUEUE_* 테이블 데이터 백업 및 데이터 보정 방안
## 백업 데이터 기간
20230228부터 작업일 전날까지

## 백업 및 데이터 보정 절차
백업 대상 테이블
- AGT_QUEUE_SUBHR
- AGT_QUEUE_HOUR
- AGT_QUEUE_DAY
- AGT_QUEUE_WEEK
- AGT_QUEUE_MONTH
- AGT_QUEUE_QRTR
- AGT_QUEUE_YEAR

(1) 하기 쿼리를 실행하여 상기 테이블들에 대한 백업 데이터를 보존할 테이블을 생성합니다.
```oracle-sql
CREATE TABLE AGT_QUEUE_SUBHR_BACKUP
AS SELECT *
FROM AGT_QUEUE_SUBHR AQS
WHERE AQS.DATE_TIME_KEY >= dbo.F_D2U(20230228)
AND AQS.DATE_TIME_KEY < dbo.F_D2U(작업일)
```

(2) 하기 쿼리를 실행하여 상기 테이블들에 대한 보정된 데이터를 보존할 테이블을 생성합니다.
```oracle-sql
CREATE TABLE AGT_QUEUE_SUBHR_REPLACE
AS SELECT
    AQSB.DATE_TIME_KEY AS DATE_TIME_KEY,
    AQSB.RESOURCE_KEY AS RESOURCE_KEY,
    AQSB.TENANT_KEY AS TENANT_KEY,
    AQSB.GROUP_COMBINATION_KEY AS GROUP_COMBINATION_KEY,
    AQSB.MEDIA_TYPE_KEY AS MEDIA_TYPE_KEY,
    AQSB.INTERACTION_TYPE_KEY AS INTERACTION_TYPE_KEY,
    AQSB.INTERACTION_DESCRIPTOR_KEY AS INTERACTION_DESCRIPTOR_KEY,
    AQSB.WORKBIN_KEY AS WORKBIN_KEY,
    AQSB.USER_DATA_KEY1 AS USER_DATA_KEY1,
    -2 AS USER_DATA_KEY2,
    SUM(AQSB.ENTERED) AS ENTERED,
    SUM(AQSB.CLEARED) AS CLEARED,
    ... 생략 ...
    SUM(AQSB.CONSULT_RCV_ACC_WARM_TIME) AS CONSULT_RCV_ACC_WARM_TIME
FROM AGT_QUEUE_SUBHR_BACKUP AQSB
GROUP BY 
    AQSB.DATE_TIME_KEY,
    AQSB.RESOURCE_KEY,
    AQSB.TENANT_KEY,
    AQSB.GROUP_COMBINATION_KEY,
    AQSB.MEDIA_TYPE_KEY,
    AQSB.INTERACTION_TYPE_KEY,
    AQSB.INTERACTION_DESCRIPTOR_KEY,
    AQSB.WORKBIN_KEY,
    AQSB.USER_DATA_KEY1
```

(3) 하기 쿼리를 실행하여 원본 테이블에 있는 데이터를 삭제합니다.
```oracle-sql
DELETE FROM AGT_QUEUE_SUBHR AQS
WHERE AQS.DATE_TIME_KEY >= dbo.F_D2U(20230228)
AND AQS.DATE_TIME_KEY < dbo.F_D2U(작업일)
```

(4) 하기 쿼리를 실행하여 보정된 데이터를 삽입합니다.
```oracle-sql
INSERT INTO AGT_QUEUE_SUBHR
SELECT * FROM AGT_QUEUE_SUBHR_REPLACE
```

(5) 상기 절차를 각 테이블마다 수행합니다.

## 롤백 방안
(1) 하기 쿼리를 실행하여 삽입한 보정된 데이터를 삭제합니다.
```oracle-sql
DELETE FROM AGT_QUEUE_SUBHR AQS
WHERE AQS.DATE_TIME_KEY >= dbo.F_D2U(20230228)
AND AQS.DATE_TIME_KEY < dbo.F_D2U(작업일)
```

(2) 하기 쿼리를 실행하여 원본 데이터를 삽입합니다.
```oracle-sql
INSERT INTO AGT_QUEUE_SUBHR
SELECT * FROM AGT_QUEUE_SUBHR_BACKUP
```

(3) 상기 절차를 각 테이블마다 수행합니다.

## 작업일 당일 데이터 보정 작업 절차
작업일은 2023년 04월 07일 금요일로 가정하겠습니다.

(1) InfoMart 재기동 이후에 `AGT_QUEUE_ACC_AGENT_*` 테이블 또는 `AGT_QUEUE_ABN_*` 테이블을 참고하여 USER_DATA_KEY2
컬럼에 -2를 제외한 값이 삽입되기 시작하는 시각을 알아냅니다.

(2) 만약 해당 시각이 14:15부터라고 가정한다면 하기 쿼리를 하기 쿼리를 실행하여 백업 데이터를 보존할 테이블을 생성합니다.
```oracle-sql
CREATE TABLE AGT_QUEUE_SUBHR_BACKUP_TODAY
AS SELECT *
FROM AGT_QUEUE_SUBHR AQS
WHERE AQS.DATE_TIME_KEY >= dbo.F_D2U(20230407)
AND AQS.DATE_TIME_KEY < dbo.F_D2U(20230407 14:15)
```

(3) 하기 쿼리를 실행하여 상기 테이블들에 대한 보정된 데이터를 보존할 테이블을 생성합니다.
```oracle-sql
CREATE TABLE AGT_QUEUE_SUBHR_REPLACE_TODAY
AS SELECT
    AQSBT.DATE_TIME_KEY AS DATE_TIME_KEY,
    AQSBT.RESOURCE_KEY AS RESOURCE_KEY,
    AQSBT.TENANT_KEY AS TENANT_KEY,
    AQSBT.GROUP_COMBINATION_KEY AS GROUP_COMBINATION_KEY,
    AQSBT.MEDIA_TYPE_KEY AS MEDIA_TYPE_KEY,
    AQSBT.INTERACTION_TYPE_KEY AS INTERACTION_TYPE_KEY,
    AQSBT.INTERACTION_DESCRIPTOR_KEY AS INTERACTION_DESCRIPTOR_KEY,
    AQSBT.WORKBIN_KEY AS WORKBIN_KEY,
    AQSBT.USER_DATA_KEY1 AS USER_DATA_KEY1,
    -2 AS USER_DATA_KEY2,
    SUM(AQSB.ENTERED) AS ENTERED,
    SUM(AQSB.CLEARED) AS CLEARED,
    ... 생략 ...
    SUM(AQSB.CONSULT_RCV_ACC_WARM_TIME) AS CONSULT_RCV_ACC_WARM_TIME
FROM AGT_QUEUE_SUBHR_BACKUP_TODAY AQSBT
GROUP BY 
    AQSBT.DATE_TIME_KEY,
    AQSBT.RESOURCE_KEY,
    AQSBT.TENANT_KEY,
    AQSBT.GROUP_COMBINATION_KEY,
    AQSBT.MEDIA_TYPE_KEY,
    AQSBT.INTERACTION_TYPE_KEY,
    AQSBT.INTERACTION_DESCRIPTOR_KEY,
    AQSBT.WORKBIN_KEY,
    AQSBT.USER_DATA_KEY1
```

(4) 하기 쿼리를 실행하여 원본 테이블에 있는 데이터를 삭제합니다.
```oracle-sql
DELETE FROM AGT_QUEUE_SUBHR AQS
WHERE AQS.DATE_TIME_KEY >= dbo.F_D2U(20230407)
AND AQS.DATE_TIME_KEY < dbo.F_D2U(20230407 14:15)
```

(5) 하기 쿼리를 실행하여 보정된 데이터를 삽입합니다.
```oracle-sql
INSERT INTO AGT_QUEUE_SUBHR
SELECT * FROM AGT_QUEUE_SUBHR_REPLACE_TODAY
```

(6) 상기 절차를 각 테이블마다 수행합니다.